modified from "HexGrid by Daniel Carrier" by Sanka

If you've toyed around enough and you actually want to modify the code, here's overviews of each class. For more details, there's comments in the code itself.

For one computer, HexGrid.cs is the main script to control the game. I have the playing field running it, but you could just as well use an empty. It should be modified to change the controls of the game. For networks, Player.cs takes care of the game on each individual computer, but ServerGameController.cs takes care of sending commands between computers.

Instances of HexPosition.cs are used for positions on the grid and have various methods to make dealing with these positions easier. While it does have an underlying two-dimensional coordinate system, using it directly is not recommended. There are also static methods and variables centered around the playing field. They let you do things like assign variables to positions. This class is the most complete, and is intended to be modified little if at all. It is also the most heavily documented. You may need to read through the comments in that class to see what the public methods are, but there is no need to read the code itself. The documentation is in the code, though it's written in a way that lets the IDE show it to you when you use the methods.

Unit.cs is a script that must be attached to units. All of the GameObjects running this script must be parented to a GameObject held by HexGrid.cs. It should be modified if you want to change how units in general work. If you want particular units that work differently, then it is recommended to make a new class that inherits from Unit.cs.

AStar.cs is a simple implementation of A*, a path-finding algorithm. It should be modified if you want to change which cells can be moved through, make some cells take longer to cross, etc. However, it is not currently set up to easily be modified, so if you need to do that, sorry. Currently, units can pass through any cell except ones containing units or marked "Obstacle". If you want to be specific about your obstacles, you can assign a value to the variable Obstacle at that HexPosition and it will work just as well.

NegativeBinomialDistribution.cs is a random number generator that generates numbers in a negative binomial distribution. I made it because I don't see any reason to stick with uniform distributions for damage and such in games. Negative binomial distribution is a discrete, positive, infinitely divisible distribution and I think that makes it perfect for games with discrete HP. If you want to use floats instead of integers for HP, I suggest gamma distribution, which is in attached SimpleRNG.cs (written by John D. Cook http://www.johndcook.com). If you feel the need to use a different distribution, replacing this class entirely would probably be better than modifying it.

AI.cs controls the AI. It's currently built to start attacking with its strongest unit, then move to weaker units, and to chase and attack enemies in order of their strength-to-HP ratio.